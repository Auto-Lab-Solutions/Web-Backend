"""
Backup/Restore Utility Module

This module provides shared utilities for backup and restore operations,
including event construction, parameter validation, and Lambda invocation patterns.
Used by both api-backup-restore and backup-restore functions to reduce code duplication.
"""

import json
import os
import boto3
from botocore.exceptions import ClientError
import business_logic_utils as biz


class BackupRestoreManager:
    """Manager for backup/restore operations with shared utilities"""
    
    def __init__(self):
        self.lambda_client = boto3.client('lambda')
    
    def get_backup_function_name(self):
        """Get backup function name from environment with validation"""
        backup_function_name = os.environ.get('BACKUP_FUNCTION_NAME')
        if not backup_function_name:
            raise biz.BusinessLogicError("BACKUP_FUNCTION_NAME environment variable not set", 500)
        return backup_function_name
    
    def build_base_event(self, operation, staff_context, request_id, reason=None):
        """Build base event structure with common fields"""
        staff_user_email = staff_context.get('staff_user_email', 'unknown')
        staff_user_id = staff_context.get('staff_user_id', 'unknown')
        
        base_event = {
            'operation': operation,
            'manual_trigger': True,
            'triggered_by': staff_user_email,
            'staff_user_id': staff_user_id,
            'request_id': request_id
        }
        
        if reason:
            base_event['reason'] = reason
        
        return base_event
    
    def build_backup_event(self, request_data, staff_context, request_id):
        """Build event for backup operation"""
        base_event = self.build_base_event(
            'backup', 
            staff_context, 
            request_id, 
            request_data.get('reason', 'Manual backup via API')
        )
        
        # Add backup-specific parameters
        base_event.update({
            'tables': request_data.get('tables', []),  # Empty list means all tables
            'skip_cleanup': request_data.get('skip_cleanup', False),
            'timestamp': None  # Will be generated by backup function
        })
        
        return base_event
    
    def build_restore_event(self, request_data, staff_context, request_id):
        """Build event for restore operation with validation"""
        backup_timestamp = request_data.get('backup_timestamp')
        if not backup_timestamp:
            raise biz.BusinessLogicError("backup_timestamp is required for restore operation", 400)
        
        base_event = self.build_base_event(
            'restore', 
            staff_context, 
            request_id, 
            request_data.get('reason', 'Manual restore via API')
        )
        
        # Add restore-specific parameters
        base_event.update({
            'backup_timestamp': backup_timestamp,
            'tables': request_data.get('tables', []),  # Empty list means all tables
            'clear_tables': request_data.get('clear_tables', True),
            'create_backup': request_data.get('create_backup', True),
            'restore_s3_objects': request_data.get('restore_s3_objects', True)
        })
        
        return base_event
    
    def build_cleanup_event(self, request_data, staff_context, request_id):
        """Build event for cleanup operation"""
        base_event = self.build_base_event(
            'cleanup', 
            staff_context, 
            request_id, 
            request_data.get('reason', 'Manual cleanup via API')
        )
        
        # Add cleanup-specific parameters
        base_event.update({
            'tables': request_data.get('tables', [])  # Empty list means all tables
        })
        
        return base_event
    
    def build_list_backups_event(self, staff_context, request_id):
        """Build event for list backups operation"""
        staff_user_email = staff_context.get('staff_user_email', 'unknown')
        
        return {
            'operation': 'list_backups',
            'requested_by': staff_user_email,
            'request_id': request_id
        }
    
    def invoke_backup_function(self, event, invocation_type='Event'):
        """
        Invoke backup function with the given event
        
        Args:
            event: Event payload to send to backup function
            invocation_type: 'Event' for async, 'RequestResponse' for sync
        
        Returns:
            Response from Lambda invocation
        """
        backup_function_name = self.get_backup_function_name()
        
        try:
            print(f"Invoking backup function {backup_function_name} with type {invocation_type}")
            print(f"Event payload: {json.dumps(event, default=str)}")
            
            response = self.lambda_client.invoke(
                FunctionName=backup_function_name,
                InvocationType=invocation_type,
                Payload=json.dumps(event)
            )
            
            return response
            
        except ClientError as e:
            error_code = e.response.get('Error', {}).get('Code', 'Unknown')
            error_message = e.response.get('Error', {}).get('Message', str(e))
            raise biz.BusinessLogicError(f"Failed to invoke backup function: {error_code} - {error_message}", 500)
        except Exception as e:
            raise biz.BusinessLogicError(f"Failed to invoke backup function: {str(e)}", 500)
    
    def invoke_backup_function_async(self, event):
        """Invoke backup function asynchronously (for backup operations)"""
        return self.invoke_backup_function(event, 'Event')
    
    def invoke_backup_function_sync(self, event):
        """Invoke backup function synchronously and parse response (for restore/cleanup/list operations)"""
        response = self.invoke_backup_function(event, 'RequestResponse')
        
        try:
            # Parse response payload
            response_payload = json.loads(response['Payload'].read().decode('utf-8'))
            return response_payload
        except json.JSONDecodeError as e:
            raise biz.BusinessLogicError(f"Failed to parse backup function response: {str(e)}", 500)
        except Exception as e:
            raise biz.BusinessLogicError(f"Failed to read backup function response: {str(e)}", 500)
    
    def validate_sync_response(self, response_payload, operation):
        """Validate synchronous response from backup function"""
        status_code = response_payload.get('statusCode')
        
        if status_code == 200:
            try:
                result = json.loads(response_payload.get('body', '{}'))
                return result
            except json.JSONDecodeError:
                # If body is not JSON, return the raw body
                return response_payload.get('body', {})
        else:
            error_body = response_payload.get('body', 'Unknown error')
            raise biz.BusinessLogicError(f"{operation.capitalize()} failed: {error_body}", status_code or 500)
    
    def build_api_response_data(self, operation, staff_context, request_id, result_data, parameters):
        """Build standardized API response data"""
        staff_user_email = staff_context.get('staff_user_email', 'unknown')
        
        response_data = {
            'message': f'{operation.capitalize()} completed successfully',
            'operation': operation,
            'request_id': request_id,
            'triggered_by': staff_user_email,
            'parameters': parameters
        }
        
        # Add operation-specific result data
        if operation == 'backup':
            response_data['status'] = 'initiated'
            response_data['backup_function'] = self.get_backup_function_name()
        elif operation in ['restore', 'cleanup']:
            response_data[f'{operation}_result'] = result_data
        elif operation == 'list_backups':
            # For list_backups, return the result directly
            return result_data
        
        return response_data


def get_backup_restore_manager():
    """Factory function to get BackupRestoreManager instance"""
    return BackupRestoreManager()
